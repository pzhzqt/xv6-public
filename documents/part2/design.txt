(Qitian Zeng: A20324028)(Deman Yang: A20395988)

Design of system call:

Since for each process, it can already access its own page directory table by calling its own attribute pgdir, we don't need to change any memory management.
In mmu.h:
#define NPDENTRIES      1024    // # directory entries per page directory
#define NPTENTRIES      1024    // # PTEs per page table
difined the number of entries per page directory, and the number of entries per page table. Therefore, we just need to loop through all the page table entries and pick out the present ones and the ones that are accessible and writable by user program.

Altough the assignment says we don't have to describe the implementation of the system call, but since we didn't change any memory management, we can only describe the system call.
Changes we made:
add "int myMemory(void);" to user.h
add "SYSCALL(myMemory)" to usys.S
add "#define SYS_myMemory 22" to syscall.h
add "[SYS_myMemory] sys_mem," to syscall.c at line 130
add "extern int sys_mem(void);" to syscall.c at line 106
add the below function to sysproc.c:
//print the number of pages allocated
//return 0 on success
int
sys_mem(void)
{
	pte_t *pgtab;
	struct proc *proc=myproc();
	int num_page=0,num_user=0;

	for (int i=0;i<NPDENTRIES;i++){
		if (proc->pgdir[i] & PTE_P){
			pgtab = (pte_t *)P2V(PTE_ADDR(proc->pgdir[i]));
			for (int j=0;j<NPTENTRIES;j++){
				if (pgtab[j] & PTE_P){
					num_page++;
					if((pgtab[j] & PTE_U) && (pgtab[j] & PTE_W)){
						num_user++;
					}
				}
			}
		}
	}

	cprintf("number of total pages: %d\n",num_page);
	cprintf("number of user accessible and writable pages: %d\n",num_user);

	return 0;
}


Manual:
Declaration:
	int myMemory(void);
Print out the total number of pages allocated to the current process and the total number of pages that are accessible and writable by user program, and return 0 on success.

