When a program calls write(fd,10,n), it pushes all the arguments to the stack and calls the write function defined in usys.S:
.globl write;
write:
  movl $SYS_write, %eax;
  int $T_SYSCALL;
  ret
Here, movl passes the value of SYS_write, which is defined as 16 in syscall.h to the register %eax. And int instruction will cause the hardware to raise the privilege level and issues software interrupt in the idt table, and the value of T_SYSCALL, which is defined as 64 in traps.h, goes to the corresponding element in the table. A gate is created from idt[64] to vectors[64] at booting time, which is shown in line 24 of trap.c, so it invokes vectors[64], which is define in vectors.S which is generated by vectors.pl:
.globl vector64
vector64:
  pushl $0
  pushl $64
  jmp alltraps

We see, it pushes the trap number to the stack and jump to alltraps(), which is defined in trapasm.S

In trapasm.S, alltraps() first pushes a few registers unto the stack and then sets up data segments, then it pushes the value in %esp register to the stack, and calls trap() function at line 20, therefore value in %esp is passed to the function as the parameter.

trap() is defined in trap.c at line 36, it first checks if the it is a system call, and checks it the process is still alive, then invoke syscall() at line 43.

syscall() is defined in syscall.c at line 133, it assigns the system call number (SYS_write) to num, then check if it's a valid system call, then invoke syscalls[SYS_write]() at line 142.

syscalls[]() is defined in the same file, from line 124 we know sys_write() will be invoked.

sys_write() is defined in sysfile.c at line 81, in line 88, it calls argfd(0,0,&fd) which is defined in sysfile.c at line 21, and it calls argint(0,&fd) at line 27.

argint() is defined in syscall.c. argint(0,&fd) calls fetchint((myproc()->tf->esp)+4,&fd). fetchint() is defined in syscall.c at line 17, it fetches the first argument to the call write(fd,10,n), which is fd, assign the value to fd in argfd, and return 0. Therefore argint() will return 0 to argfd then at line 29 in sysfile.c, since fd is an undefined number, the if statement will hold, therefore argfd() will return -1, causing the if statement in sys_write() to hold, so sys_write() will return -1 to curproc->tf->eax in syscall(), then syscall() returns to trap(), and trap() returns to alltraps(), then the code falls through trapret, which pops out some values from the stack and invoke iret, which will lower the privilege level to user mode and return to the line calling "int $T_SYSCALL", which is back to write() in usys.S:
.globl write;
write:
  movl $SYS_write, %eax;
  int $T_SYSCALL;
  ret
the only line left is ret, which will return -1 to the user call.
